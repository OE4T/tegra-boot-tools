# tegra-bootloader-update

This tool replaces the L4T `nv_update_engine` tool for TX2/Xavier
systems and the `l4t_payload_updater_t210` tool for TX1/Nano systems.
It applies a bootloader update payload (BUP) generated by the L4T
flashing tools.

## For T186/T194 platforms

On TX2/Xavier platforms, the typical use case for `tegra-bootloader-update`
is to apply a BUP as part of an OTA full rootfs installation when
implementing a full A/B update strategy.

### Differences from `nv_update_engine`

* No need for the `/etc/nv_boot_control.conf` file. The TNSPEC used to
  determine boot component compatibility is directly derived from the
  CVM EEPROM contents.
* No `nv_update_verifier` service at boot time. Such a service could
  be implemented, if desired, but for full A/B upgrades that include
  the rootfs, the verify-and-overwrite feature of the L4T update
  verifier is undesirable.
* The tool can be used to completely initialize all boot components,
  provided the BUP payload contains all of them (default BUP generation
  in L4T does **not** do this).
* This tool compares the contents of each boot component from the current
  content before updating and skips unneeded writes, saving update time
  on Xavier NX systems that store boot components in QSPI flash.
* This tool automatically enables A/B redundancy during an update if
  it has not yet been enabled.

A script is included that emulates a subset of the `nv_update_engine`
command-line interface using `tegra-bootloader-update`.

## For T210 platforms

The TX1/Nano platforms do not support A/B updates for the bootloaders,
and you must take that factor into consideration when implementing your
update strategy. They *do* implement redundancy for the boot partitions,
but only as a fallback used should there be a failure during an update.

The `tegra-bootloader-update` tool can be used for applying BUPs on
TX1/Nano platforms, replacing the `l4t_payload_updater_t210` script
included in the L4T BSP.

### Differences from `l4t_payload_updater_t210`

* Written in C, rather than Python.
* Boot partition information is read from a configuration file at
  runtime, rather than being hard-coded into the tool.
* Automatically handles either SPI flash or eMMC boot partitions,
  without depending on the MACHINE name as the Python tool does.
